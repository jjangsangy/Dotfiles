# SOURCED FILES
# ==========================================================

for file in ${HOME}/\.{'path','aliases','prompt.sh','jump.sh'}; do
    [ -r "${file}" ] && [ -f "${file}" ] && source "${file}"
done

if [[ "$OSTYPE" =~ "cygwin" ]]; then
    for file in ${HOME}/\.{'.minttyrc','dark_cyg','light_cyg',}; do
        [ -r "${file}" ] && [ -f "${file}" ] && source "${file}"
    done
fi

# ==========================================================
# DIRCOLORS
# ==========================================================
# AUTHOR: Sang Han
# DEPENDS: GNU coreutils
# For Mac OS X coreutils must be installed first either manually
# or with a package manager.
alias 'ls=ls --color=auto'
eval_dircolors() {
    # USAGE: By default, this function checks and evaluates .dircolors
    #        in users $HOME directory.
    #        Takes 1 argument which will be expanded to .dircolor_${STYLE}
    #        for evaluating specific dircolor styles
    [[  -n $1 ]] && local STYLE=$1

    if [[ -r $HOME/.dircolors${STYLE/#/_} ]]; then
        eval "$(dircolors $HOME/.dircolors${STYLE/#/_})"
    fi
}

eval_dircolors

[[ "$COLORFGBG" == "11;15" ]] && eval_dircolors light
[[ "$COLORFGBG" == "12;8" ]] && eval_dircolors dark

# ==========================================================
# ENVAR
# ==========================================================
export GREP_OPTIONS='--color=auto'
export PATH=/usr/local/bin:${HOME}/bin:$HOME/.cabal/bin:$HOME/.rvm/bin:$PATH
export EDITOR=vim
export HISTIGNORE="ls:cd:echo:history:clear"
export PROJECT_HOME="${HOME}/Projects"
export PIP_RESPECT_VIRTUALENV=true
export PYTHONDONTWRITEBYTECODE=1

function powerline_precmd() {
      export PS1="$(~/.powerline-shell 2> /dev/null)"
}

export PROMPT_COMMAND="powerline_precmd; $PROMPT_COMMAND"

# ==========================================================
# Prompt
# ==========================================================

# ==========================================================
# Depreciated Modules
# ==========================================================
# export WORKON_HOME=$HOME/.virtualenvs
# export PIP_VIRTUALENV_BASE=$WORKON_HOME
# source "${HOME}/.powerline.sh"
# source activate py27

# source /usr/local/bin/virtualenvwrapper.sh
# source "${HOME}/.virtualenvs/py3k/bin/activate"

# eval "$(pyenv init -)"
# export PYENV_VERSION="py34"


# ==========================================================
# Homebrew
# ==========================================================
if brew --prefix &> /dev/null;  then
    export HOMEBREW_EDITOR=vim
    export HOMEBREW_VERBOSE=true
    export HOMEBREW_GITHUB_API_TOKEN=45316a902d54f9d4129bb559d04a85529f4625aa

    if [ -f "$(brew --prefix)/etc/bash_completion" ]; then
        source "$(brew --prefix)/etc/bash_completion"
    fi
fi

# ==========================================================
# Functions
# ==========================================================
function clean_pyc() {
    local depth=${1}
    find . -type f -name '*.pyc' -maxdepth ${depth:-1} -exec rm '{}' \;
}

# Clean Pesky .DS.Store files
function clean_ds() {
    local depth=${1}
    find . -type f -name '.DS_Store' -maxdepth ${depth:-1} -exec rm '{}' \;
}

function homebrew() {
    brew update && brew upgrade
}

# ==========================================================
# Docker
# ==========================================================
if which docker &> /dev/null; then
    alias d_ip="docker inspect --format '{{ .NetworkSettings.IPAddress }}'"

    export DOCKER_HOST=tcp://$(boot2docker ip 2>/dev/null):$(boot2docker info | jq '.["DockerPort"]')

    docker_run() {
        docker run -it --rm ${1} /bin/bash -l
    }

    docked() {
        # Returns Last Image ID
        docker ps -l -q
    }

    d_ls() {
        docker images
    }

    d_clean() {
        # Cleanup Empty Containers
        docker rm $(docker ps -a -q) 2>/dev/null
    }

    d_rm() {
        # Remove Untagged Images
        local group=${1-'<none>'}
        docker rmi $(awk '{if ($1=="'${group}'") print $3}' <(docker images))
    }
fi

# ==========================================================
# Ruby
# ==========================================================
if which rbenv &> /dev/null; then
    export RBENV_ROOT="$HOME/.rbenv/bin"
    export PATH="$HOME/.rbenv/shims":$PATH
    export RBENV_VERSION="2.1.3"
    eval "$(rbenv init -)"
fi

# ==========================================================
# Go
# ==========================================================
export PATH=$PATH:/usr/local/opt/go/libexec/bin
if [ -d $HOME/Go ]; then
    export GOPATH=$HOME/Go
    export GOBIN=$PATH:$GOPATH/bin
fi

# ==========================================================
# Completions
# ==========================================================
_pip_completion()
{
    COMPREPLY=( $( COMP_WORDS="${COMP_WORDS[*]}" \
                   COMP_CWORD=$COMP_CWORD \
                   PIP_AUTO_COMPLETE=1 $1 ) )
}
complete -o default -F _pip_completion pip

# NPM Completion
COMP_WORDBREAKS=${COMP_WORDBREAKS/=/}
COMP_WORDBREAKS=${COMP_WORDBREAKS/@/}
export COMP_WORDBREAKS

if type complete &>/dev/null; then
  _npm_completion () {
    local si="$IFS"
    IFS=$'\n' COMPREPLY=($(COMP_CWORD="$COMP_CWORD" \
                           COMP_LINE="$COMP_LINE" \
                           COMP_POINT="$COMP_POINT" \
                           npm completion -- "${COMP_WORDS[@]}" \
                           2>/dev/null)) || return $?
    IFS="$si"
  }
  complete -F _npm_completion npm
elif type compdef &>/dev/null; then
  _npm_completion() {
    si=$IFS
    compadd -- $(COMP_CWORD=$((CURRENT-1)) \
                 COMP_LINE=$BUFFER \
                 COMP_POINT=0 \
                 npm completion -- "${words[@]}" \
                 2>/dev/null)
    IFS=$si
  }
  compdef _npm_completion npm
elif type compctl &>/dev/null; then
  _npm_completion () {
    local cword line point words si
    read -Ac words
    read -cn cword
    let cword-=1
    read -l line
    read -ln point
    si="$IFS"
    IFS=$'\n' reply=($(COMP_CWORD="$cword" \
                       COMP_LINE="$line" \
                       COMP_POINT="$point" \
                       npm completion -- "${words[@]}" \
                       2>/dev/null)) || return $?
    IFS="$si"
  }
  compctl -K _npm_completion npm
fi
